name: Deploy to AWS ECS (Single Secret)

on:
  push:
    branches: [ main, develop ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: perfect-po-dev-api
  ECS_CLUSTER: perfect-po-dev-cluster
  ECS_SERVICE: perfect-po-dev-api-service
  ECS_TASK_DEFINITION: perfect-po-dev-api-task

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    environment: production

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Validate Environment Variables
      run: |
        echo "ğŸ” Validating ENV_FILE_DEV secret before build..."
        
        # Check if ENV_FILE_DEV secret exists and contains required variables
        if [ -z "${{ secrets.ENV_FILE_DEV }}" ]; then
          echo "âŒ ENV_FILE_DEV secret is missing"
          echo "ğŸ’¡ Add ENV_FILE_DEV secret to GitHub repository secrets"
          echo "   This secret should contain all environment variables in key=value format"
          exit 1
        fi
        
        echo "âœ… ENV_FILE_DEV secret is set"
        
        # Extract and validate key variables from the secret content
        echo "ğŸ” Validating secret content..."
        
        # Check for MONGODB_URL (not MONGODB_URI as per our app config)
        if [[ "${{ secrets.ENV_FILE_DEV }}" != *"MONGODB_URL="* ]]; then
          echo "âŒ ENV_FILE_DEV missing MONGODB_URL"
          exit 1
        fi
        
        # Check for JWT_SECRET_KEY
        if [[ "${{ secrets.ENV_FILE_DEV }}" != *"JWT_SECRET_KEY="* ]]; then
          echo "âŒ ENV_FILE_DEV missing JWT_SECRET_KEY"
          exit 1
        fi
        
        # Check for KEEPA_API_KEY
        if [[ "${{ secrets.ENV_FILE_DEV }}" != *"KEEPA_API_KEY="* ]]; then
          echo "âŒ ENV_FILE_DEV missing KEEPA_API_KEY"
          exit 1
        fi
        
        # Check for AWS credentials
        if [[ "${{ secrets.ENV_FILE_DEV }}" != *"AWS_ACCESS_KEY_ID="* ]]; then
          echo "âŒ ENV_FILE_DEV missing AWS_ACCESS_KEY_ID"
          exit 1
        fi
        
        if [[ "${{ secrets.ENV_FILE_DEV }}" != *"AWS_SECRET_ACCESS_KEY="* ]]; then
          echo "âŒ ENV_FILE_DEV missing AWS_SECRET_ACCESS_KEY"
          exit 1
        fi
        
        # Check for localhost in MongoDB URL
        if [[ "${{ secrets.ENV_FILE_DEV }}" == *"localhost"* ]] || [[ "${{ secrets.ENV_FILE_DEV }}" == *"127.0.0.1"* ]]; then
          echo "âŒ ENV_FILE_DEV contains localhost - must use remote MongoDB"
          exit 1
        fi
        
        echo "âœ… All required environment variables found in ENV_FILE_DEV"
        echo "âœ… MongoDB connection is remote (no localhost)"
        echo "âœ… Validation passed - build can proceed"

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build a docker container and push it to ECR
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Create/Update AWS Secret
      run: |
        # Use the ENV_FILE_DEV secret directly
        env_file_content="${{ secrets.ENV_FILE_DEV }}"
        
        # Try to update existing secret, create if it doesn't exist
        if aws secretsmanager describe-secret --secret-id "perfect-po-env-file" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "Updating existing secret..."
          aws secretsmanager update-secret \
            --secret-id "perfect-po-env-file" \
            --secret-string "$env_file_content" \
            --region ${{ env.AWS_REGION }}
        else
          echo "Creating new secret..."
          aws secretsmanager create-secret \
            --name "perfect-po-env-file" \
            --description "Environment variables for Perfect PO API" \
            --secret-string "$env_file_content" \
            --region ${{ env.AWS_REGION }}
        fi

    - name: Fill in the new image ID in the Amazon ECS task definition
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: deployment/aws/ecs-task-definition-single-secret.json
        container-name: perfect-po-api
        image: ${{ steps.build-image.outputs.image }}

    - name: Deploy Amazon ECS task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true

    - name: Get the service URL from ECS
      id: service-url
      run: |
        # Get the load balancer DNS name
        SERVICE_ARN=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }} --region ${{ env.AWS_REGION }} --query 'services[0].loadBalancers[0].targetGroupArn' --output text)
        if [ "$SERVICE_ARN" != "None" ] && [ "$SERVICE_ARN" != "" ]; then
          TARGET_GROUP_ARN=$(echo $SERVICE_ARN)
          LOAD_BALANCER_ARN=$(aws elbv2 describe-target-groups --target-group-arns $TARGET_GROUP_ARN --region ${{ env.AWS_REGION }} --query 'TargetGroups[0].LoadBalancerArns[0]' --output text)
          if [ "$LOAD_BALANCER_ARN" != "None" ] && [ "$LOAD_BALANCER_ARN" != "" ]; then
            DNS_NAME=$(aws elbv2 describe-load-balancers --load-balancer-arns $LOAD_BALANCER_ARN --region ${{ env.AWS_REGION }} --query 'LoadBalancers[0].DNSName' --output text)
            echo "url=$DNS_NAME" >> $GITHUB_OUTPUT
            echo "Service URL: $DNS_NAME"
          else
            echo "url=None" >> $GITHUB_OUTPUT
            echo "No load balancer found"
          fi
        else
          echo "url=None" >> $GITHUB_OUTPUT
          echo "No target group found"
        fi

    - name: Wait a bit for the service to be fully ready
      run: |
        if [ "${{ steps.service-url.outputs.url }}" != "None" ]; then
          echo "Waiting for service to be ready..."
          sleep 30
        else
          echo "No load balancer URL found, skipping health check"
        fi

    - name: Health check
      run: |
        if [ "${{ steps.service-url.outputs.url }}" != "None" ]; then
          echo "Testing health endpoint..."
          curl -f http://${{ steps.service-url.outputs.url }}/health || echo "Health check failed"
        else
          echo "âš ï¸  No load balancer URL found, skipping health check"
        fi

    - name: Deployment Summary
      run: |
        echo "ğŸ‰ Deployment completed successfully!"
        echo "ğŸ“± Service URL: ${{ steps.service-url.outputs.url }}"
        echo "ğŸ³ Image: ${{ steps.build-image.outputs.image }}"
        echo "ğŸ—ï¸  Environment: ${{ github.ref_name }}"
        echo "ğŸ“ Commit: ${{ github.sha }}"
